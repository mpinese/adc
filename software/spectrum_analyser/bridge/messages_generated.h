// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGES_BRIDGEMESSAGES_H_
#define FLATBUFFERS_GENERATED_MESSAGES_BRIDGEMESSAGES_H_

#include "flatbuffers/flatbuffers.h"

namespace BridgeMessages {

struct CaptureRequest;
struct CaptureRequestBuilder;

struct CaptureResponse;
struct CaptureResponseBuilder;

enum Channel {
  Channel_Left = 0,
  Channel_Right = 1,
  Channel_MIN = Channel_Left,
  Channel_MAX = Channel_Right
};

inline const Channel (&EnumValuesChannel())[2] {
  static const Channel values[] = {
    Channel_Left,
    Channel_Right
  };
  return values;
}

inline const char * const *EnumNamesChannel() {
  static const char * const names[3] = {
    "Left",
    "Right",
    nullptr
  };
  return names;
}

inline const char *EnumNameChannel(Channel e) {
  if (flatbuffers::IsOutRange(e, Channel_Left, Channel_Right)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesChannel()[index];
}

enum Window {
  Window_Rectangular = 0,
  Window_Hann = 1,
  Window_BlackmanHarris = 2,
  Window_MIN = Window_Rectangular,
  Window_MAX = Window_BlackmanHarris
};

inline const Window (&EnumValuesWindow())[3] {
  static const Window values[] = {
    Window_Rectangular,
    Window_Hann,
    Window_BlackmanHarris
  };
  return values;
}

inline const char * const *EnumNamesWindow() {
  static const char * const names[4] = {
    "Rectangular",
    "Hann",
    "BlackmanHarris",
    nullptr
  };
  return names;
}

inline const char *EnumNameWindow(Window e) {
  if (flatbuffers::IsOutRange(e, Window_Rectangular, Window_BlackmanHarris)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWindow()[index];
}

struct CaptureRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CaptureRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHANNEL = 4,
    VT_N_SAMPLES = 6,
    VT_WINDOW = 8
  };
  BridgeMessages::Channel channel() const {
    return static_cast<BridgeMessages::Channel>(GetField<int8_t>(VT_CHANNEL, 0));
  }
  uint32_t n_samples() const {
    return GetField<uint32_t>(VT_N_SAMPLES, 0);
  }
  BridgeMessages::Window window() const {
    return static_cast<BridgeMessages::Window>(GetField<int8_t>(VT_WINDOW, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CHANNEL) &&
           VerifyField<uint32_t>(verifier, VT_N_SAMPLES) &&
           VerifyField<int8_t>(verifier, VT_WINDOW) &&
           verifier.EndTable();
  }
};

struct CaptureRequestBuilder {
  typedef CaptureRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channel(BridgeMessages::Channel channel) {
    fbb_.AddElement<int8_t>(CaptureRequest::VT_CHANNEL, static_cast<int8_t>(channel), 0);
  }
  void add_n_samples(uint32_t n_samples) {
    fbb_.AddElement<uint32_t>(CaptureRequest::VT_N_SAMPLES, n_samples, 0);
  }
  void add_window(BridgeMessages::Window window) {
    fbb_.AddElement<int8_t>(CaptureRequest::VT_WINDOW, static_cast<int8_t>(window), 0);
  }
  explicit CaptureRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CaptureRequestBuilder &operator=(const CaptureRequestBuilder &);
  flatbuffers::Offset<CaptureRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CaptureRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<CaptureRequest> CreateCaptureRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    BridgeMessages::Channel channel = BridgeMessages::Channel_Left,
    uint32_t n_samples = 0,
    BridgeMessages::Window window = BridgeMessages::Window_Rectangular) {
  CaptureRequestBuilder builder_(_fbb);
  builder_.add_n_samples(n_samples);
  builder_.add_window(window);
  builder_.add_channel(channel);
  return builder_.Finish();
}

struct CaptureResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CaptureResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SAMPLES = 4,
    VT_SPECTRUM = 6
  };
  const flatbuffers::Vector<int32_t> *samples() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SAMPLES);
  }
  const flatbuffers::Vector<double> *spectrum() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_SPECTRUM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SAMPLES) &&
           verifier.VerifyVector(samples()) &&
           VerifyOffset(verifier, VT_SPECTRUM) &&
           verifier.VerifyVector(spectrum()) &&
           verifier.EndTable();
  }
};

struct CaptureResponseBuilder {
  typedef CaptureResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_samples(flatbuffers::Offset<flatbuffers::Vector<int32_t>> samples) {
    fbb_.AddOffset(CaptureResponse::VT_SAMPLES, samples);
  }
  void add_spectrum(flatbuffers::Offset<flatbuffers::Vector<double>> spectrum) {
    fbb_.AddOffset(CaptureResponse::VT_SPECTRUM, spectrum);
  }
  explicit CaptureResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CaptureResponseBuilder &operator=(const CaptureResponseBuilder &);
  flatbuffers::Offset<CaptureResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CaptureResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<CaptureResponse> CreateCaptureResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> samples = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> spectrum = 0) {
  CaptureResponseBuilder builder_(_fbb);
  builder_.add_spectrum(spectrum);
  builder_.add_samples(samples);
  return builder_.Finish();
}

inline flatbuffers::Offset<CaptureResponse> CreateCaptureResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *samples = nullptr,
    const std::vector<double> *spectrum = nullptr) {
  auto samples__ = samples ? _fbb.CreateVector<int32_t>(*samples) : 0;
  auto spectrum__ = spectrum ? _fbb.CreateVector<double>(*spectrum) : 0;
  return BridgeMessages::CreateCaptureResponse(
      _fbb,
      samples__,
      spectrum__);
}

}  // namespace BridgeMessages

#endif  // FLATBUFFERS_GENERATED_MESSAGES_BRIDGEMESSAGES_H_
